<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ambient Weather – Daily Avg Temp, Cumulative GDD, Daily Rain & Bud Break</title>
    <!-- Chart.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js Zoom Plugin from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
    <!-- Chart.js Datalabels Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <!-- sql.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/sql-wasm.js"></script>
    <style>
        /* Remove default margins/padding for full-screen usage */
        body {
            font-family: Arial, sans-serif;
            background: #fafafa;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        h1, h2, h3 {
            text-align: center;
            margin: 10px 0;
        }

        /* Toggle buttons for slide-out panels */
        #toggleLeftPanel, #toggleRightPanel {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
        }

        #toggleLeftPanel {
            left: 0;
        }

        #toggleRightPanel {
            right: 0;
        }

        /* Auto Refresh Toggle Control */
        #autoRefreshControl {
            text-align: center;
            margin: 10px 0;
        }

        /* Flex container for panels and chart */
        .flex-container {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            width: 100%;
            box-sizing: border-box;
            transition: margin 0.3s ease;
        }

        /* Left slide-out panel (months) */
        #leftPanel {
            width: fit-content;
            transition: width 0.3s ease;
            background: #e0e0e0;
            box-sizing: border-box;
            padding: 10px;
            text-align: left;
        }

        #leftPanel.hidden {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        /* Right slide-out panel (years) */
        #rightPanel {
            width: fit-content;
            transition: width 0.3s ease;
            background: #e0e0e0;
            box-sizing: border-box;
            padding: 10px;
            text-align: right;
        }

        #rightPanel.hidden {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        /* Chart container fills remaining space */
        #chartContainer {
            position: relative;
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
            height: 80vh;
        }

        /* Ensure the canvas fills its container */
        canvas {
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            width: 100% !important;
            height: 100% !important;
            display: block;
        }

        /* Ensure the checkboxes are stacked */
        #monthControls label, #yearControls label {
            display: block;
            margin: 5px 0;
        }

        /* Custom legend container styling for the bottom legend */
        #legendContainer {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 15px;
            padding: 5px;
            box-sizing: border-box;
        }

        /* Updated legend item style for bottom legend (no button look) */
        #legendContainer .legend-item {
            display: inline-flex;
            align-items: center;
            padding: 2px 4px;
            margin: 2px;
            font-size: 0.9em;
            color: #333;
            background: transparent;
            border: none;
            border-radius: 0;
            cursor: pointer;
        }

        /* Tooltip for vertical line labels */
        #vlineTooltip {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 2000;
        }
    </style>
    <script>
        // Register the ChartDataLabels plugin
        Chart.register(ChartDataLabels);
    </script>
</head>
<body>
<h1>Robert Clay Vineyards</h1>
<h2>GDD 50 Data Dashboard</h2>
<h3>
    Data Sources:
    <a href="https://ambientweather.net/">ambientweather.net</a> &amp;
    <a href="https://open-meteo.com/en/docs/historical-weather-api">Open-Meteo</a>
</h3>
<!-- Toggle buttons for slide-out panels -->
<button id="toggleLeftPanel">Toggle Months</button>
<button id="toggleRightPanel">Toggle Years</button>
<!-- Auto Refresh Toggle -->
<div id="autoRefreshControl">
    <label>
        <input type="checkbox" id="autoRefreshCheckbox" checked>
        Auto Refresh
    </label>
</div>
<!-- Mode Dropdown and Threshold Input (hidden by default) -->
<div id="modeControl" style="text-align: center; margin: 10px 0;">
    <label for="modeSelect">Mode:</label>
    <select id="modeSelect">
        <option value="normal" selected>Normal</option>
        <option value="nearest">Nearest Neighbor</option>
    </select>
    <span id="thresholdContainer" style="display: none; margin-left: 10px;">
      <label for="nnThreshold">Threshold:</label>
      <input type="number" id="nnThreshold" value="10.0" step="0.1" style="width: 70px;">
    </span>
</div>
<div class="container">
    <div class="flex-container">
        <!-- Left slide-out panel for Month Filters -->
        <div id="leftPanel">
            <h3>Select Months</h3>
            <div id="monthControls">
                <label><input type="checkbox" id="allMonths" checked> All Months</label>
                <label><input type="checkbox" name="month" value="1" checked> January</label>
                <label><input type="checkbox" name="month" value="2" checked> February</label>
                <label><input type="checkbox" name="month" value="3" checked> March</label>
                <label><input type="checkbox" name="month" value="4" checked> April</label>
                <label><input type="checkbox" name="month" value="5" checked> May</label>
                <label><input type="checkbox" name="month" value="6" checked> June</label>
                <label><input type="checkbox" name="month" value="7" checked> July</label>
                <label><input type="checkbox" name="month" value="8" checked> August</label>
                <label><input type="checkbox" name="month" value="9" checked> September</label>
                <label><input type="checkbox" name="month" value="10" checked> October</label>
                <label><input type="checkbox" name="month" value="11" checked> November</label>
                <label><input type="checkbox" name="month" value="12" checked> December</label>
            </div>
            <!-- Container for Grape Varietal legend items (left justified) -->
            <div id="grapeVarietalLegend"></div>
        </div>
        <!-- Chart Container -->
        <div id="chartContainer">
            <!-- Export to PNG Button in top right -->
            <button id="exportButton"
                    style="position: absolute; top: 10px; right: 10px; z-index: 1000; padding: 10px 20px; font-size: 16px; cursor: pointer;">
                Export Chart to PNG
            </button>
            <h2>Daily Avg Temp, Cumulative GDD, Daily Rain & Bud Break</h2>
            <canvas id="dailyChart"></canvas>
            <!-- Bottom legend container for non–grape–varietal groups -->
            <div id="legendContainer"></div>
        </div>
        <!-- Right slide-out panel for Year Filters -->
        <div id="rightPanel">
            <h3>Select Years</h3>
            <div id="yearControls">
                <!-- Dynamic year checkboxes will be inserted here -->
            </div>
        </div>
    </div>
</div>
<!-- Tooltip element for vertical line labels -->
<div id="vlineTooltip"></div>
<script>
    // Global auto-refresh settings
    let autoRefresh = true;
    let refreshIntervalId = null;
    const AUTO_REFRESH_PERIOD = 60000; // 60 seconds

    // Sample event flags for years (modify as needed)
    const yearEvents = {
        "2000": ["Neutral", "Solar Max [8]"],
        "2001": ["Neutral", "Solar Max [8]"],
        "2002": ["Neutral", "Solar Transition [7]"],
        "2003": ["El Niño", "Solar Transition [6]"],
        "2004": ["Neutral", "Solar Transition [5]"],
        "2005": ["Neutral", "Solar Transition [4]"],
        "2006": ["Neutral", "Solar Transition [3]"],
        "2007": ["El Niño", "Solar Transition [2]"],
        "2008": ["La Niña", "Solar Min [1]"],
        "2009": ["La Niña", "Solar Min [1]"],
        "2010": ["La Niña", "Solar Transition [2]"],
        "2011": ["La Niña", "Solar Transition [3]"],
        "2012": ["La Niña", "Solar Transition [4]"],
        "2013": ["Neutral", "Solar Transition [4]"],
        "2014": ["Neutral", "Solar Max [6]"],
        "2015": ["El Niño", "Solar Transition [5]"],
        "2016": ["El Niño", "Solar Transition [4]"],
        "2017": ["La Niña", "Solar Transition [3]"],
        "2018": ["Neutral", "Solar Min [2]"],
        "2019": ["Weak El Niño", "Solar Min [1]"],
        "2020": ["Neutral", "Solar Min [1]"],
        "2021": ["La Niña", "Solar Transition [2]"],
        "2022": ["Moderate La Niña", "Solar Transition [3]"],
        "2023": ["El Niño", "Solar Transition [4]"],
        "2024": ["Transition from El Niño to Neutral", "Solar Transition [6]"],
        "2025": ["Neutral", "Solar Max [10]"]
    };

    // Custom Plugin: horizontalLinePlugin draws horizontal lines at 32°F, 50°F, and 86°F.
    const horizontalLinePlugin = {
        id: 'horizontalLinePlugin',
        afterDraw(chart, args, options) {
            const {ctx, chartArea: {left, right}, scales: {y}} = chart;
            if (!y) return;

            function drawLine(yValue, color, text) {
                const yPixel = y.getPixelForValue(yValue);
                ctx.save();
                ctx.beginPath();
                ctx.setLineDash([6, 6]);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.moveTo(left, yPixel);
                ctx.lineTo(right, yPixel);
                ctx.stroke();
                ctx.restore();
                ctx.fillStyle = color;
                ctx.font = '12px Arial';
                ctx.fillText(text, left + 5, yPixel - 5);
            }

            drawLine(32, 'green', 'Freeze (32°F)');
            drawLine(50, 'blue', 'Base Temp (50°F)');
            drawLine(86, 'red', 'Ceiling Temp (86°F)');
        }
    };
    Chart.register(horizontalLinePlugin);

    // Custom Plugin: verticalLinePlugin (draws only lines)
    const verticalLinePlugin = {
        id: 'verticalLinePlugin',
        afterDraw(chart, args, options) {
            const currentYear = String(new Date().getFullYear());
            if (!selectedYears || !selectedYears.includes(currentYear)) return;
            const ctx = chart.ctx;
            const xScale = chart.scales.x;
            if (!options.lines) return;
            options.lines.forEach(line => {
                const xPixel = xScale.getPixelForValue(line.xLabel);
                if (xPixel === undefined || isNaN(xPixel)) return;
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(xPixel, chart.chartArea.top);
                ctx.lineTo(xPixel, chart.chartArea.bottom);
                ctx.lineWidth = line.lineWidth || 2;
                ctx.strokeStyle = line.color || "red";
                ctx.stroke();
                ctx.restore();
            });
        }
    };
    Chart.register(verticalLinePlugin);

    let db = null;
    let dailyChart;
    let SQL;
    let selectedYears = []; // Global array for selected years
    let yearColorMapping = {}; // Global persistent color mapping

    function log(message) {
        const now = new Date().toISOString().replace("T", " ").replace("Z", "");
        console.log("[" + now + "] " + message);
    }

    function log_debug(message) {
        if (DEBUG) {
            log("[DEBUG] " + message);
        }
    }

    let DEBUG = true;
    let DB_FILENAME = "ambient_weather.sqlite";

    function saveFilterSettings() {
        const monthCheckboxes = document.querySelectorAll("input[name='month']");
        const selectedMonths = Array.from(monthCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);
        localStorage.setItem("selectedMonths", JSON.stringify(selectedMonths));
        const yearCheckboxes = document.querySelectorAll("input[name='year']");
        const selYears = Array.from(yearCheckboxes)
            .filter(cb => cb.checked)
            .map(cb => cb.value);
        localStorage.setItem("selectedYears", JSON.stringify(selYears));
    }

    function loadFilterSettings() {
        const storedMonths = localStorage.getItem("selectedMonths");
        if (storedMonths) {
            const selectedMonths = JSON.parse(storedMonths);
            document.querySelectorAll("input[name='month']").forEach(cb => {
                cb.checked = selectedMonths.includes(cb.value);
            });
            const allChecked = Array.from(document.querySelectorAll("input[name='month']")).every(cb => cb.checked);
            const allMonthsCb = document.getElementById("allMonths");
            if (allMonthsCb) allMonthsCb.checked = allChecked;
        }
        const storedYears = localStorage.getItem("selectedYears");
        if (storedYears) {
            selectedYears = JSON.parse(storedYears);
            document.querySelectorAll("input[name='year']").forEach(cb => {
                cb.checked = selectedYears.includes(cb.value);
            });
            const allChecked = Array.from(document.querySelectorAll("input[name='year']")).every(cb => cb.checked);
            const allYearsCb = document.getElementById("allYears");
            if (allYearsCb) allYearsCb.checked = allChecked;
        }
    }

    // Compute a simple linear regression trend line
    function computeTrendLine(data) {
        let x = [], y = [];
        for (let i = 0; i < data.length; i++) {
            if (data[i] !== null && !isNaN(data[i])) {
                x.push(i);
                y.push(data[i]);
            }
        }
        if (x.length === 0) {
            return new Array(data.length).fill(null);
        }
        let n = x.length;
        let sumX = x.reduce((a, b) => a + b, 0);
        let sumY = y.reduce((a, b) => a + b, 0);
        let sumXY = 0, sumXX = 0;
        for (let i = 0; i < n; i++) {
            sumXY += x[i] * y[i];
            sumXX += x[i] * x[i];
        }
        let slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        let intercept = (sumY - slope * sumX) / n;
        let trend = [];
        for (let i = 0; i < data.length; i++) {
            trend.push(slope * i + intercept);
        }
        return trend;
    }

    function refreshData() {
        const modeSelect = document.getElementById("modeSelect");
        if (modeSelect && modeSelect.value === "nearest") {
            applyNearestNeighborMode();
        } else {
            loadAndPlotData();
        }
    }

    function startAutoRefresh() {
        if (!refreshIntervalId) {
            refreshIntervalId = setInterval(refreshData, AUTO_REFRESH_PERIOD);
            log("Auto Refresh started (every " + (AUTO_REFRESH_PERIOD / 1000) + " seconds).");
        }
    }

    function stopAutoRefresh() {
        if (refreshIntervalId) {
            clearInterval(refreshIntervalId);
            refreshIntervalId = null;
            log("Auto Refresh stopped.");
        }
    }

    function getLegendCategory(label) {
        if (label.includes("Trend")) return "Avg Temp Trend";
        if (label.includes("Min Temp") || label.includes("Max Temp")) return "Min/Max Temp";
        if (label.includes("Avg Temp")) return "Avg Temperature";
        if (label.includes("Cumulative GDD")) return "Cumulative GDD";
        if (label.includes("Daily Rain Total")) return "Daily Rain Totals";
        if (label.includes("Sunspots Daily Total")) return "Sunspot Daily Total";
        if (label.includes("Pest")) return "Pest Spray";
        return "Grape Varietal";
    }

    // Initialize sql.js and load the database
    initSqlJs({locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.12.0/${file}`})
        .then(function (SQLLib) {
            SQL = SQLLib;
            return fetch(DB_FILENAME);
        })
        .then(response => response.arrayBuffer())
        .then(buffer => {
            db = new SQL.Database(new Uint8Array(buffer));
            log("Database loaded successfully.");
            populateYearControls();
            loadFilterSettings();
            refreshData();
            startAutoRefresh();
            document.querySelectorAll("input[name='year']").forEach(cb => {
                cb.addEventListener("change", function () {
                    let allChecked = true;
                    document.querySelectorAll("input[name='year']").forEach(box => {
                        if (!box.checked) {
                            allChecked = false;
                        }
                    });
                    const allYearsCb = document.getElementById("allYears");
                    if (allYearsCb) allYearsCb.checked = allChecked;
                    saveFilterSettings();
                    loadAndPlotData();
                });
            });
            const allYearsCb = document.getElementById("allYears");
            if (allYearsCb) {
                allYearsCb.addEventListener("change", function () {
                    const newState = this.checked;
                    document.querySelectorAll("input[name='year']").forEach(cb => {
                        cb.checked = newState;
                    });
                    saveFilterSettings();
                    loadAndPlotData();
                });
            }
            document.querySelectorAll("input[name='month']").forEach(cb => {
                cb.addEventListener("change", function () {
                    let allChecked = true;
                    document.querySelectorAll("input[name='month']").forEach(box => {
                        if (!box.checked) {
                            allChecked = false;
                        }
                    });
                    const allMonthsCb = document.getElementById("allMonths");
                    if (allMonthsCb) allMonthsCb.checked = allChecked;
                    saveFilterSettings();
                    loadAndPlotData();
                });
            });
            const allMonthsCb = document.getElementById("allMonths");
            if (allMonthsCb) {
                allMonthsCb.addEventListener("change", function () {
                    const newState = this.checked;
                    document.querySelectorAll("input[name='month']").forEach(cb => {
                        cb.checked = newState;
                    });
                    saveFilterSettings();
                    loadAndPlotData();
                });
            }
            document.getElementById("autoRefreshCheckbox").addEventListener("change", function () {
                autoRefresh = this.checked;
                log("Auto Refresh is now " + (autoRefresh ? "enabled" : "disabled"));
                if (autoRefresh) {
                    startAutoRefresh();
                } else {
                    stopAutoRefresh();
                }
            });
        }).catch(err => console.error("Error initializing database:", err));

    function generateDistinctColor(index, total) {
        const hue = Math.floor((360 / total) * index);
        return `hsl(${hue}, 70%, 50%)`;
    }

    function populateYearControls() {
        let storedMapping = sessionStorage.getItem("yearColorMapping");
        if (storedMapping) {
            yearColorMapping = JSON.parse(storedMapping);
        } else {
            yearColorMapping = {};
        }
        const res = db.exec("SELECT DISTINCT substr(date, 1, 4) as year FROM readings ORDER BY year ASC;");
        const yearControls = document.getElementById("yearControls");
        yearControls.innerHTML = "";
        const allYearsLabel = document.createElement("label");
        allYearsLabel.innerHTML = `<input type="checkbox" id="allYears" checked> All Years`;
        yearControls.appendChild(allYearsLabel);
        if (res.length > 0) {
            const years = res[0].values.map(row => row[0]);
            const totalYears = years.length;
            years.forEach((year, index) => {
                let labelText = year;
                if (yearEvents.hasOwnProperty(year) && yearEvents[year].length > 0) {
                    labelText += " (" + yearEvents[year].join(", ") + ")";
                }
                if (!yearColorMapping[year]) {
                    yearColorMapping[year] = generateDistinctColor(index, totalYears);
                }
                sessionStorage.setItem("yearColorMapping", JSON.stringify(yearColorMapping));
                const label = document.createElement("label");
                label.innerHTML = `<input type="checkbox" name="year" value="${year}" checked>
                     <span style="display:inline-block; width:12px; height:12px; background-color:${yearColorMapping[year]}; margin-right:5px;"></span>
                     ${labelText}`;
                yearControls.appendChild(label);
            });
        }
    }

    function queryDataByYearAndMonths(year, months) {
        const monthList = months.map(m => m).join(",");
        const sqlQuery = `
            SELECT substr(date, 6, 5) AS day_key,
                   MIN(tempf)         AS minTempF,
                   MAX(tempf)         AS maxTempF,
                   AVG(tempf)         AS avgTempF,
                   MAX(gdd)           AS maxCumGDD,
                   MAX(dailyrainin)   AS rainTotal
            FROM readings
            WHERE substr(date, 1, 4) = '${year}'
              AND cast(substr(date, 6, 2) as integer) IN (${monthList})
            GROUP BY day_key
            ORDER BY day_key ASC;
        `;
        const stmt = db.prepare(sqlQuery);
        const results = [];
        while (stmt.step()) {
            results.push(stmt.getAsObject());
        }
        stmt.free();
        return results;
    }

    function querySunspotsDataByYearAndMonths(year, months) {
        const monthList = months.join(",");
        const sqlQuery = `
            SELECT substr(date, 6, 5) AS day_key,
                   daily_total        AS sunspotCount
            FROM sunspots
            WHERE substr(date, 1, 4) = '${year}'
              AND cast(substr(date, 6, 2) as integer) IN (${monthList})
            ORDER BY day_key ASC;
        `;
        const stmt = db.prepare(sqlQuery);
        const results = {};
        while (stmt.step()) {
            const row = stmt.getAsObject();
            results[row.day_key] = row.sunspotCount;
        }
        stmt.free();
        return results;
    }

    function processYearlyData(rows) {
        const data = {};
        rows.forEach(r => {
            data[r.day_key] = {
                minTempF: parseFloat(r.minTempF),
                maxTempF: parseFloat(r.maxTempF),
                avgTempF: parseFloat(r.avgTempF),
                maxCumGDD: parseFloat(r.maxCumGDD),
                rainTotal: parseFloat(r.rainTotal)
            };
        });
        return data;
    }

    function alignData(commonLabels, dataByDay, field) {
        return commonLabels.map(label => dataByDay[label] ? dataByDay[label][field] : null);
    }

    // Compute Bud Break Points for grape varieties
    function computeBudBreakPoints(selectedYearsArr, commonLabels, yearlyData) {
        const result = db.exec("SELECT variety, heat_summation FROM grapevine_gdd ORDER BY variety");
        if (result.length === 0) return [];
        const grapeData = result[0].values;
        const budBreakByVariety = {};
        grapeData.forEach(row => {
            budBreakByVariety[row[0]] = [];
        });
        selectedYearsArr.forEach(year => {
            const dataForYear = yearlyData[year];
            grapeData.forEach(row => {
                const variety = row[0];
                const threshold = row[1];
                for (let i = 0; i < commonLabels.length; i++) {
                    const dayKey = commonLabels[i];
                    const record = dataForYear[dayKey];
                    if (record && record.maxCumGDD >= threshold) {
                        budBreakByVariety[variety].push({x: dayKey, y: record.maxCumGDD, year: year});
                        break;
                    }
                }
            });
        });
        const scatterDatasets = [];
        Object.keys(budBreakByVariety).forEach(variety => {
            const points = budBreakByVariety[variety];
            if (points.length > 0) {
                scatterDatasets.push({
                    label: variety,
                    data: points,
                    borderColor: getColorForVariety(variety),
                    backgroundColor: getColorForVariety(variety),
                    pointRadius: 6,
                    type: 'scatter',
                    showLine: false,
                    order: 2,
                    yAxisID: 'y1',
                    spanGaps: false
                });
            }
        });
        return scatterDatasets;
    }

    // Compute Pest Spray Points – plot only the min_gdd, with extra details in the tooltip.
    // Compute Pest Spray Points – plot only the min_gdd points for the current year
    function computePestSprayPoints(selectedYearsArr, commonLabels, yearlyData) {
        const currentYear = String(new Date().getFullYear());
        // Only proceed if the current year is among the selected years.
        if (!selectedYearsArr.includes(currentYear)) return [];

        // Query updated table: common_name, scientific_name, stage, min_gdd, max_gdd, dormant
        const result = db.exec("SELECT common_name, scientific_name, stage, min_gdd, max_gdd, dormant FROM vineyard_pests ORDER BY common_name, min_gdd");
        if (!result || result.length === 0) return [];
        const pestData = result[0].values;
        const pestPointsMap = {};

        // Only iterate for the current year.
        pestData.forEach(row => {
            const pest = row[0]; // common_name
            const scientificName = row[1];
            const stage = row[2];
            const minThreshold = row[3]; // min_gdd
            const maxThreshold = row[4]; // max_gdd
            const dormant = row[5]; // dormant
            const dataForYear = yearlyData[currentYear];
            if (!dataForYear) return; // Skip if no data for current year.
            let point = null;
            for (let i = 0; i < commonLabels.length; i++) {
                const dayKey = commonLabels[i];
                const record = dataForYear[dayKey];
                if (record && record.maxCumGDD >= minThreshold) {
                    point = {
                        x: dayKey,
                        y: minThreshold, // plot at the min_gdd level
                        year: currentYear,
                        scientific_name: scientificName,
                        stage: stage,
                        max_gdd: maxThreshold,
                        dormant: dormant
                    };
                    break;
                }
            }
            if (point) {
                if (!pestPointsMap[pest]) {
                    pestPointsMap[pest] = [];
                }
                pestPointsMap[pest].push(point);
            }
        });

        const pestDatasets = [];
        Object.keys(pestPointsMap).forEach(pest => {
            pestDatasets.push({
                label: pest,
                data: pestPointsMap[pest],
                pointStyle: 'rect',
                pointRadius: 6,
                backgroundColor: getColorForVariety(pest),
                borderColor: getColorForVariety(pest),
                type: 'scatter',
                showLine: false,
                order: 8,
                yAxisID: 'y1',
                hideInLegend: true  // Do not show these in the legend.
            });
        });
        return pestDatasets;
    }

    function getColorForVariety(variety) {
        const grapeColors = {
            "Chardonnay": "rgb(255,140,0)",
            "Sauvignon Blanc": "rgb(255,215,0)",
            "Riesling": "rgb(255,69,0)",
            "Pinot Gris": "rgb(30,144,255)",
            "Semillon": "rgb(255,99,71)",
            "Cabernet Sauvignon": "rgb(139,0,0)",
            "Merlot": "rgb(220,20,60)",
            "Pinot Noir": "rgb(128,0,0)",
            "Syrah": "rgb(178,34,34)",
            "Zinfandel": "rgb(138,43,226)",
            "Sangiovese": "rgb(165,42,42)",
            "Tempranillo": "rgb(199,21,133)",
            "Malbec": "rgb(128,0,128)",
            "Grenache": "rgb(255,105,180)",
            "Nebbiolo": "rgb(75,0,130)"
        };
        if (grapeColors[variety]) {
            return grapeColors[variety];
        }
        const fallbackColors = [
            "rgb(255,0,0)",
            "rgb(0,255,0)",
            "rgb(0,0,255)",
            "rgb(255,255,0)",
            "rgb(255,0,255)",
            "rgb(0,255,255)"
        ];
        return fallbackColors[Math.floor(Math.random() * fallbackColors.length)];
    }

    function randomColor() {
        const r = Math.floor(Math.random() * 156) + 100;
        const g = Math.floor(Math.random() * 156) + 100;
        const b = Math.floor(Math.random() * 156) + 100;
        return `rgb(${r},${g},${b})`;
    }

    function darkenColor(rgbStr, factor) {
        const result = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/.exec(rgbStr);
        if (!result) {
            return rgbStr;
        }
        let r = Math.floor(parseInt(result[1]) * factor);
        let g = Math.floor(parseInt(result[2]) * factor);
        let b = Math.floor(parseInt(result[3]) * factor);
        return `rgb(${r},${g},${b})`;
    }

    function lightenColor(rgbStr, factor) {
        const result = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/.exec(rgbStr);
        if (!result) return rgbStr;
        let r = parseInt(result[1]);
        let g = parseInt(result[2]);
        let b = parseInt(result[3]);
        r = Math.floor(r + (255 - r) * factor);
        g = Math.floor(g + (255 - g) * factor);
        b = Math.floor(b + (255 - b) * factor);
        return `rgb(${r},${g},${b})`;
    }

    function getLegendGroupStates() {
        const stored = localStorage.getItem("legendGroupStates");
        return stored ? JSON.parse(stored) : {};
    }

    function saveLegendGroupStates(states) {
        localStorage.setItem("legendGroupStates", JSON.stringify(states));
    }

    function generateCustomLegend(chart) {
        const legendContainer = document.getElementById('legendContainer');
        legendContainer.innerHTML = '';
        const grapeVarietalContainer = document.getElementById('grapeVarietalLegend');
        if (grapeVarietalContainer) grapeVarietalContainer.innerHTML = '';
        const groups = {};
        chart.data.datasets.forEach((ds, index) => {
            // Skip datasets flagged to hide in legend
            if (ds.hideInLegend) return;
            const cat = getLegendCategory(ds.label);
            if (!groups[cat]) groups[cat] = [];
            groups[cat].push({ds, index});
        });
        let legendGroupStates = getLegendGroupStates();
        Object.keys(groups).forEach(category => {
            if (category === "Grape Varietal") {
                const header = document.createElement('div');
                header.textContent = category;
                header.style.fontWeight = 'bold';
                header.style.marginTop = '10px';
                header.style.textAlign = 'left';
                grapeVarietalContainer.appendChild(header);
                const groupDiv = document.createElement('div');
                groupDiv.style.display = 'flex';
                groupDiv.style.flexDirection = 'column';
                groupDiv.style.gap = '8px';
                groups[category].forEach(item => {
                    const {ds, index} = item;
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.style.opacity = chart.data.datasets[index].hidden ? 0.5 : 1;
                    let markerHTML = `<span style="display:inline-block; width:12px; height:12px; background-color:${ds.borderColor}; border-radius:50%; margin-right:5px;"></span>`;
                    legendItem.innerHTML = markerHTML + ds.label;
                    legendItem.style.cursor = 'pointer';
                    legendItem.onclick = function () {
                        chart.data.datasets[index].hidden = !chart.data.datasets[index].hidden;
                        legendItem.style.opacity = chart.data.datasets[index].hidden ? 0.5 : 1;
                        chart.update();
                    };
                    groupDiv.appendChild(legendItem);
                });
                grapeVarietalContainer.appendChild(groupDiv);
            } else {
                const groupWrapper = document.createElement('div');
                groupWrapper.style.display = "inline-flex";
                groupWrapper.style.flexDirection = "column";
                groupWrapper.style.alignItems = "flex-start";
                groupWrapper.style.marginRight = "15px";
                const headerContainer = document.createElement('div');
                headerContainer.style.display = "flex";
                headerContainer.style.alignItems = "center";
                headerContainer.style.gap = "5px";
                const groupCheckbox = document.createElement('input');
                groupCheckbox.type = "checkbox";
                if (!(category in legendGroupStates)) {
                    legendGroupStates[category] = true;
                }
                groupCheckbox.checked = legendGroupStates[category];
                const headerLabel = document.createElement('span');
                headerLabel.textContent = category;
                headerLabel.style.fontWeight = 'bold';
                headerContainer.appendChild(groupCheckbox);
                headerContainer.appendChild(headerLabel);
                groupWrapper.appendChild(headerContainer);
                const groupDiv = document.createElement('div');
                groupDiv.style.display = "flex";
                groupDiv.style.flexDirection = "column";
                groupDiv.style.gap = "8px";
                const groupLegendItems = [];
                groups[category].forEach(item => {
                    const {ds, index} = item;
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.style.opacity = chart.data.datasets[index].hidden ? 0.5 : 1;
                    let markerHTML = `<span style="display:inline-block; width:12px; height:12px; background-color:${ds.borderColor}; margin-right:5px;"></span>`;
                    legendItem.innerHTML = markerHTML + ds.label;
                    legendItem.style.cursor = 'pointer';
                    legendItem.onclick = function () {
                        chart.data.datasets[index].hidden = !chart.data.datasets[index].hidden;
                        legendItem.style.opacity = chart.data.datasets[index].hidden ? 0.5 : 1;
                        chart.update();
                    };
                    groupDiv.appendChild(legendItem);
                    groupLegendItems.push({legendItem, index});
                });
                groupWrapper.appendChild(groupDiv);
                legendContainer.appendChild(groupWrapper);
                groupCheckbox.addEventListener('change', function () {
                    let newHidden = !groupCheckbox.checked;
                    groupLegendItems.forEach(item => {
                        let idx = item.index;
                        chart.data.datasets[idx].hidden = newHidden;
                        item.legendItem.style.opacity = newHidden ? 0.5 : 1;
                    });
                    let legendGroupStates = getLegendGroupStates();
                    legendGroupStates[category] = groupCheckbox.checked;
                    saveLegendGroupStates(legendGroupStates);
                    chart.update();
                });
                if (!groupCheckbox.checked) {
                    groupLegendItems.forEach(item => {
                        let idx = item.index;
                        chart.data.datasets[idx].hidden = true;
                        item.legendItem.style.opacity = 0.5;
                    });
                }
            }
        });
        saveLegendGroupStates(legendGroupStates);
    }

    /* ================= Data Query and Plotting ================= */
    function loadAndPlotData() {
        if (!db) return;
        const yearCheckboxes = document.querySelectorAll("input[name='year']:checked");
        selectedYears = Array.from(yearCheckboxes).map(cb => cb.value);
        const monthCheckboxes = document.querySelectorAll("input[name='month']:checked");
        const selectedMonths = Array.from(monthCheckboxes).map(cb => parseInt(cb.value));
        if (selectedYears.length === 0 || selectedMonths.length === 0) return;
        let storedMapping = sessionStorage.getItem("yearColorMapping");
        if (storedMapping) {
            yearColorMapping = JSON.parse(storedMapping);
        } else {
            yearColorMapping = {};
        }
        let commonLabelsSet = new Set();
        let yearlyData = {};
        selectedYears.forEach(year => {
            const rows = queryDataByYearAndMonths(year, selectedMonths);
            const data = processYearlyData(rows);
            yearlyData[year] = data;
            Object.keys(data).forEach(day_key => commonLabelsSet.add(day_key));
        });
        const commonLabels = Array.from(commonLabelsSet).sort();
        let datasets = [];
        const currentYearStr = String(new Date().getFullYear());
        selectedYears.forEach(year => {
            const dataForYear = yearlyData[year];
            const minTempData = alignData(commonLabels, dataForYear, "minTempF");
            const maxTempData = alignData(commonLabels, dataForYear, "maxTempF");
            const avgTempData = alignData(commonLabels, dataForYear, "avgTempF");
            const trendData = computeTrendLine(avgTempData);
            const gddData = alignData(commonLabels, dataForYear, "maxCumGDD");
            const rainData = alignData(commonLabels, dataForYear, "rainTotal");
            if (!yearColorMapping[year]) {
                yearColorMapping[year] = randomColor();
            }
            let baseColor = yearColorMapping[year];
            sessionStorage.setItem("yearColorMapping", JSON.stringify(yearColorMapping));
            let bandFillColor = baseColor.replace("rgb(", "rgba(").replace(")", ",0.3)");
            let colorAvg = lightenColor(baseColor, 0.3);
            let colorRain = lightenColor(baseColor, 0.5);
            let indexMin = datasets.length;
            datasets.push({
                label: `Min Temp (°F) - ${year}`,
                data: minTempData,
                borderColor: 'transparent',
                backgroundColor: bandFillColor,
                borderWidth: 0,
                yAxisID: "y",
                type: 'line',
                fill: false,
                tension: 0.4,
                pointRadius: 0,
                order: 1,
                hideInLegend: true,
                spanGaps: false
            });
            let indexMax = datasets.length;
            datasets.push({
                label: `Min/Max Temp - ${year}`,
                data: maxTempData,
                borderColor: 'transparent',
                backgroundColor: bandFillColor,
                borderWidth: 0,
                yAxisID: "y",
                type: 'line',
                fill: '-1',
                tension: 0.4,
                pointRadius: 0,
                order: 2,
                pairIndices: [indexMin, indexMax],
                spanGaps: false
            });
            datasets.push({
                label: `Avg Temp Trend - ${year}`,
                data: trendData,
                borderColor: darkenColor(colorAvg, 0.8),
                backgroundColor: 'transparent',
                borderDash: [5, 5],
                borderWidth: (year === currentYearStr ? 4 : 2),
                yAxisID: "y",
                type: 'line',
                fill: false,
                tension: 0,
                pointRadius: 0,
                order: 3,
                spanGaps: false
            });
            datasets.push({
                label: `Avg Temp (°F) - ${year}`,
                data: avgTempData,
                borderColor: colorAvg,
                backgroundColor: 'transparent',
                borderWidth: (year === currentYearStr ? 4 : 2),
                yAxisID: "y",
                type: 'line',
                fill: false,
                tension: 0.4,
                pointRadius: 3,
                order: 4,
                spanGaps: false
            });
            datasets.push({
                label: "Cumulative GDD - " + year,
                data: gddData,
                borderColor: baseColor,
                backgroundColor: 'transparent',
                yAxisID: "y1",
                tension: 0.4,
                pointRadius: 2,
                borderDash: [10, 5],
                borderWidth: (year === currentYearStr ? 3 : 2),
                fill: false,
                type: 'line',
                order: 5,
                spanGaps: false
            });
            datasets.push({
                label: "Daily Rain Total (in) - " + year,
                data: rainData,
                backgroundColor: colorRain,
                yAxisID: "y2",
                type: 'bar',
                order: 6,
                spanGaps: false
            });
        });
        // Add Sunspots series
        selectedYears.forEach(year => {
            const sunspotData = querySunspotsDataByYearAndMonths(year, selectedMonths);
            const sunspotsAligned = commonLabels.map(label => sunspotData[label] !== undefined ? sunspotData[label] : null);
            let baseColor = yearColorMapping[year] || randomColor();
            let colorSunspot = lightenColor(baseColor, 0.8);
            datasets.push({
                label: "Sunspots Daily Total - " + year,
                data: sunspotsAligned,
                borderColor: colorSunspot,
                backgroundColor: 'transparent',
                yAxisID: "y3",
                type: "line",
                tension: 0.4,
                pointRadius: 2,
                borderWidth: (year === currentYearStr ? 4 : 2),
                order: 7,
                spanGaps: false
            });
        });
        // Add Pest Spray Points (for vineyard pests) – these won't appear in the legend.
        const pestDatasets = computePestSprayPoints(selectedYears, commonLabels, yearlyData);
        datasets = datasets.concat(pestDatasets);
        // Add Bud Break datasets for grape varieties
        const budBreakDatasets = computeBudBreakPoints(selectedYears, commonLabels, yearlyData);
        datasets = datasets.concat(budBreakDatasets);
        const legendGroupStates = getLegendGroupStates();
        datasets.forEach(ds => {
            const category = getLegendCategory(ds.label);
            if (category !== "Grape Varietal" && legendGroupStates.hasOwnProperty(category) && !legendGroupStates[category]) {
                ds.hidden = true;
            }
        });
        let verticalLines = [];
        const currentYear = String(new Date().getFullYear());
        if (selectedYears.includes(currentYear)) {
            const res = db.exec("SELECT variety, projected_bud_break FROM grapevine_gdd");
            if (res.length > 0) {
                res[0].values.forEach(row => {
                    const variety = row[0];
                    const predicted = row[1];
                    if (predicted && predicted.startsWith(currentYear)) {
                        const xLabel = predicted.substring(5);
                        verticalLines.push({
                            xLabel: xLabel,
                            color: getColorForVariety(variety),
                            label: variety + " Bud Break",
                            lineWidth: 2,
                            font: "12px Arial"
                        });
                    }
                });
            }
        }
        if (dailyChart) dailyChart.destroy();
        const ctx = document.getElementById('dailyChart').getContext('2d');
        dailyChart = new Chart(ctx, {
            type: 'line',
            data: {labels: commonLabels, datasets: datasets},
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: "Daily Avg Temp (with Min/Max Band, Trend & Actual), Cumulative GDD, Daily Rain, Bud Break, & Pest Spray"
                    },
                    // Disable the built-in legend so it doesn't appear on top
                    legend: {display: false},
                    verticalLinePlugin: {lines: verticalLines},
                    zoom: {
                        zoom: {
                            wheel: {enabled: true, speed: 0.1},
                            pinch: {enabled: true},
                            drag: {enabled: false},
                            mode: 'x'
                        },
                        pan: {enabled: true, mode: 'x'}
                    },
                    datalabels: {
                        display: false // default; pest datasets override this via tooltip callbacks
                    },
                    tooltip: {
                        mode: 'nearest',  // Only show the nearest point per pest
                        intersect: true,
                        callbacks: {
                            // Customize tooltip for pest datasets to show extra details
                            label: function (context) {
                                if (context.dataset.hideInLegend) {
                                    const point = context.raw;
                                    return context.dataset.label + ": " +
                                        "Scientific: " + point.scientific_name +
                                        ", Stage: " + point.stage +
                                        ", GDD: " + point.y + " (min), " + point.max_gdd + " (max)" +
                                        ", Dormant: " + point.dormant;
                                }
                                return context.dataset.label + ": " + context.formattedValue;
                            }
                        }
                    }
                },
                scales: {
                    x: {title: {display: true, text: "Month-Day"}},
                    y: {position: "left", title: {display: true, text: "Temperature (°F)"}},
                    y1: {
                        position: "right",
                        title: {display: true, text: "Cumulative GDD"},
                        grid: {drawOnChartArea: false}
                    },
                    y2: {
                        position: "right",
                        title: {display: true, text: "Rain Total (in)"},
                        grid: {drawOnChartArea: false},
                        beginAtZero: true
                    },
                    y3: {
                        position: "right",
                        title: {display: true, text: "Sunspots Daily Total"},
                        grid: {drawOnChartArea: false},
                        beginAtZero: true
                    }
                }
            }
        });
        generateCustomLegend(dailyChart);
    }

    function applyNearestNeighborMode() {
        if (!db) return;
        const thresholdInput = document.getElementById("nnThreshold");
        const threshold = parseFloat(thresholdInput.value) || 10.0;
        const currentYear = String(new Date().getFullYear());
        const currentYearQuery = `SELECT date, gdd
                                  FROM readings
                                  WHERE substr(date, 1, 4) = '${currentYear}'
                                  ORDER BY date DESC
                                  LIMIT 1;`;
        const stmt = db.prepare(currentYearQuery);
        let currentRecord = null;
        if (stmt.step()) {
            currentRecord = stmt.getAsObject();
        }
        stmt.free();
        if (!currentRecord) {
            console.log("No data for current year");
            return;
        }
        const currentGDD = parseFloat(currentRecord.gdd);
        const dayKey = currentRecord.date.substring(5, 10);
        const nnQuery = `SELECT substr(date, 1, 4) as year, MAX(gdd) as gdd
                         FROM readings
                         WHERE substr(date, 6, 5) = '${dayKey}'
                         GROUP BY year
                         ORDER BY year ASC;`;
        const results = db.exec(nnQuery);
        let qualifyingYears = [];
        if (results.length > 0) {
            results[0].values.forEach(row => {
                const year = row[0];
                const yearGDD = parseFloat(row[1]);
                if (Math.abs(yearGDD - currentGDD) <= threshold) {
                    qualifyingYears.push(year);
                }
            });
        }
        const yearCheckboxes = document.querySelectorAll("input[name='year']");
        yearCheckboxes.forEach(cb => {
            cb.checked = qualifyingYears.includes(cb.value);
        });
        selectedYears = qualifyingYears;
        loadAndPlotData();
    }

    document.getElementById("modeSelect").addEventListener("change", function () {
        const mode = this.value;
        if (mode === 'nearest') {
            document.getElementById("thresholdContainer").style.display = "inline";
            document.querySelectorAll("input[name='year']").forEach(cb => {
                cb.disabled = true;
            });
            const allYearsCb = document.getElementById("allYears");
            if (allYearsCb) allYearsCb.disabled = true;
            applyNearestNeighborMode();
        } else {
            document.getElementById("thresholdContainer").style.display = "none";
            document.querySelectorAll("input[name='year']").forEach(cb => {
                cb.disabled = false;
            });
            const allYearsCb = document.getElementById("allYears");
            if (allYearsCb) allYearsCb.disabled = false;
            loadAndPlotData();
        }
    });
    document.getElementById("nnThreshold").addEventListener("change", function () {
        if (document.getElementById("modeSelect").value === "nearest") {
            applyNearestNeighborMode();
        }
    });

    const tooltipEl = document.getElementById("vlineTooltip");
    document.getElementById("dailyChart").addEventListener("mousemove", function (event) {
        if (!dailyChart) return;
        const canvasPosition = this.getBoundingClientRect();
        const xPos = event.clientX - canvasPosition.left;
        const xScale = dailyChart.scales.x;
        const tolerance = 5;
        let found = false;
        if (dailyChart.options.plugins.verticalLinePlugin && dailyChart.options.plugins.verticalLinePlugin.lines) {
            dailyChart.options.plugins.verticalLinePlugin.lines.forEach(line => {
                const lineX = xScale.getPixelForValue(line.xLabel);
                if (Math.abs(xPos - lineX) <= tolerance) {
                    tooltipEl.style.display = "block";
                    tooltipEl.textContent = line.label;
                    tooltipEl.style.left = (lineX + canvasPosition.left + 10) + "px";
                    tooltipEl.style.top = (event.clientY + 10) + "px";
                    found = true;
                }
            });
        }
        if (!found) {
            tooltipEl.style.display = "none";
        }
    });

    document.getElementById("exportButton").addEventListener("click", function () {
        if (!dailyChart) {
            alert("Chart is not loaded yet.");
            return;
        }
        const link = document.createElement("a");
        link.href = dailyChart.toBase64Image();
        link.download = "chart.png";
        link.click();
    });

    document.getElementById("toggleLeftPanel").addEventListener("click", function () {
        const leftPanel = document.getElementById("leftPanel");
        leftPanel.classList.toggle("hidden");
        setTimeout(() => window.dispatchEvent(new Event('resize')), 350);
    });
    document.getElementById("toggleRightPanel").addEventListener("click", function () {
        const rightPanel = document.getElementById("rightPanel");
        rightPanel.classList.toggle("hidden");
        setTimeout(() => window.dispatchEvent(new Event('resize')), 350);
    });
    window.addEventListener("resize", function () {
        if (dailyChart) dailyChart.resize();
    });

    window.onload = refreshData;
</script>
</body>
</html>